# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Account implements Node {
  id: ID!
  name: String!
  type: AccountType!
  initialValue: Float!
  delete: Boolean
  deleteDate: DateTime
  user(where: UserWhereInput): User!
}

type Category implements Node {
  id: ID!
  name: String!
  parent(where: CategoryWhereInput): Category
  delete: Boolean
  deleteDate: DateTime
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
  user(where: UserWhereInput): User!
}

type Transaction implements Node {
  id: ID!
  value: Float!
  operation: Operation!
  category(where: CategoryWhereInput): Category!
  date: DateTime!
  description: String
  note: String
  status: Status!
  delete: Boolean
  deleteDate: DateTime
  account(where: AccountWhereInput): Account!
  user(where: UserWhereInput): User!
}

type User implements Node {
  id: ID!
  email: String!
  password: String!
  name: String!
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account!]
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
}


#
# Other Types
#

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  name: String!
  type: AccountType
  initialValue: Float
  delete: Boolean
  deleteDate: DateTime
  user: UserCreateOneWithoutAccountsInput!
}

input AccountCreateManyWithoutUserInput {
  create: [AccountCreateWithoutUserInput!]
  connect: [AccountWhereUniqueInput!]
}

input AccountCreateOneInput {
  create: AccountCreateInput
  connect: AccountWhereUniqueInput
}

input AccountCreateWithoutUserInput {
  name: String!
  type: AccountType
  initialValue: Float
  delete: Boolean
  deleteDate: DateTime
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  initialValue_ASC
  initialValue_DESC
  delete_ASC
  delete_DESC
  deleteDate_ASC
  deleteDate_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AccountPreviousValues {
  id: ID!
  name: String!
  type: AccountType!
  initialValue: Float!
  delete: Boolean
  deleteDate: DateTime
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  AND: [AccountSubscriptionWhereInput!]
  OR: [AccountSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
}

enum AccountType {
  Bank
  Wallet
  CreditCard
}

input AccountUpdateDataInput {
  name: String
  type: AccountType
  initialValue: Float
  delete: Boolean
  deleteDate: DateTime
  user: UserUpdateOneWithoutAccountsInput
}

input AccountUpdateInput {
  name: String
  type: AccountType
  initialValue: Float
  delete: Boolean
  deleteDate: DateTime
  user: UserUpdateOneWithoutAccountsInput
}

input AccountUpdateManyWithoutUserInput {
  create: [AccountCreateWithoutUserInput!]
  connect: [AccountWhereUniqueInput!]
  disconnect: [AccountWhereUniqueInput!]
  delete: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithoutUserInput!]
  upsert: [AccountUpsertWithoutUserInput!]
}

input AccountUpdateNestedInput {
  where: AccountWhereUniqueInput!
  data: AccountUpdateDataInput!
}

input AccountUpdateOneInput {
  create: AccountCreateInput
  connect: AccountWhereUniqueInput
  disconnect: AccountWhereUniqueInput
  delete: AccountWhereUniqueInput
  update: AccountUpdateNestedInput
  upsert: AccountUpsertNestedInput
}

input AccountUpdateWithoutUserDataInput {
  name: String
  type: AccountType
  initialValue: Float
  delete: Boolean
  deleteDate: DateTime
}

input AccountUpdateWithoutUserInput {
  where: AccountWhereUniqueInput!
  data: AccountUpdateWithoutUserDataInput!
}

input AccountUpsertNestedInput {
  where: AccountWhereUniqueInput!
  update: AccountUpdateDataInput!
  create: AccountCreateInput!
}

input AccountUpsertWithoutUserInput {
  where: AccountWhereUniqueInput!
  update: AccountUpdateWithoutUserDataInput!
  create: AccountCreateWithoutUserInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: AccountType
  type_not: AccountType
  type_in: [AccountType!]
  type_not_in: [AccountType!]
  initialValue: Float
  initialValue_not: Float
  initialValue_in: [Float!]
  initialValue_not_in: [Float!]
  initialValue_lt: Float
  initialValue_lte: Float
  initialValue_gt: Float
  initialValue_gte: Float
  delete: Boolean
  delete_not: Boolean
  deleteDate: DateTime
  deleteDate_not: DateTime
  deleteDate_in: [DateTime!]
  deleteDate_not_in: [DateTime!]
  deleteDate_lt: DateTime
  deleteDate_lte: DateTime
  deleteDate_gt: DateTime
  deleteDate_gte: DateTime
  user: UserWhereInput
}

input AccountWhereUniqueInput {
  id: ID
}

type AggregateAccount {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  name: String!
  delete: Boolean
  deleteDate: DateTime
  parent: CategoryCreateOneWithoutParentInput
  transactions: TransactionCreateManyWithoutCategoryInput
  user: UserCreateOneWithoutCategoriesInput!
}

input CategoryCreateManyWithoutUserInput {
  create: [CategoryCreateWithoutUserInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneWithoutParentInput {
  create: CategoryCreateWithoutParentInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateOneWithoutTransactionsInput {
  create: CategoryCreateWithoutTransactionsInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutParentInput {
  name: String!
  delete: Boolean
  deleteDate: DateTime
  transactions: TransactionCreateManyWithoutCategoryInput
  user: UserCreateOneWithoutCategoriesInput!
}

input CategoryCreateWithoutTransactionsInput {
  name: String!
  delete: Boolean
  deleteDate: DateTime
  parent: CategoryCreateOneWithoutParentInput
  user: UserCreateOneWithoutCategoriesInput!
}

input CategoryCreateWithoutUserInput {
  name: String!
  delete: Boolean
  deleteDate: DateTime
  parent: CategoryCreateOneWithoutParentInput
  transactions: TransactionCreateManyWithoutCategoryInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  delete_ASC
  delete_DESC
  deleteDate_ASC
  deleteDate_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
  delete: Boolean
  deleteDate: DateTime
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
}

input CategoryUpdateInput {
  name: String
  delete: Boolean
  deleteDate: DateTime
  parent: CategoryUpdateOneWithoutParentInput
  transactions: TransactionUpdateManyWithoutCategoryInput
  user: UserUpdateOneWithoutCategoriesInput
}

input CategoryUpdateManyWithoutUserInput {
  create: [CategoryCreateWithoutUserInput!]
  connect: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  delete: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithoutUserInput!]
  upsert: [CategoryUpsertWithoutUserInput!]
}

input CategoryUpdateOneWithoutParentInput {
  create: CategoryCreateWithoutParentInput
  connect: CategoryWhereUniqueInput
  disconnect: CategoryWhereUniqueInput
  delete: CategoryWhereUniqueInput
  update: CategoryUpdateWithoutParentInput
  upsert: CategoryUpsertWithoutParentInput
}

input CategoryUpdateOneWithoutTransactionsInput {
  create: CategoryCreateWithoutTransactionsInput
  connect: CategoryWhereUniqueInput
  disconnect: CategoryWhereUniqueInput
  delete: CategoryWhereUniqueInput
  update: CategoryUpdateWithoutTransactionsInput
  upsert: CategoryUpsertWithoutTransactionsInput
}

input CategoryUpdateWithoutParentDataInput {
  name: String
  delete: Boolean
  deleteDate: DateTime
  transactions: TransactionUpdateManyWithoutCategoryInput
  user: UserUpdateOneWithoutCategoriesInput
}

input CategoryUpdateWithoutParentInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutParentDataInput!
}

input CategoryUpdateWithoutTransactionsDataInput {
  name: String
  delete: Boolean
  deleteDate: DateTime
  parent: CategoryUpdateOneWithoutParentInput
  user: UserUpdateOneWithoutCategoriesInput
}

input CategoryUpdateWithoutTransactionsInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutTransactionsDataInput!
}

input CategoryUpdateWithoutUserDataInput {
  name: String
  delete: Boolean
  deleteDate: DateTime
  parent: CategoryUpdateOneWithoutParentInput
  transactions: TransactionUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithoutUserInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutUserDataInput!
}

input CategoryUpsertWithoutParentInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutParentDataInput!
  create: CategoryCreateWithoutParentInput!
}

input CategoryUpsertWithoutTransactionsInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutTransactionsDataInput!
  create: CategoryCreateWithoutTransactionsInput!
}

input CategoryUpsertWithoutUserInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutUserDataInput!
  create: CategoryCreateWithoutUserInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  delete: Boolean
  delete_not: Boolean
  deleteDate: DateTime
  deleteDate_not: DateTime
  deleteDate_in: [DateTime!]
  deleteDate_not_in: [DateTime!]
  deleteDate_lt: DateTime
  deleteDate_lte: DateTime
  deleteDate_gt: DateTime
  deleteDate_gte: DateTime
  parent: CategoryWhereInput
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
  user: UserWhereInput
}

input CategoryWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  createAccount(data: AccountCreateInput!): Account!
  createCategory(data: CategoryCreateInput!): Category!
  createTransaction(data: TransactionCreateInput!): Transaction!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  deleteUser(where: UserWhereUniqueInput!): User
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  updateManyAccounts(data: AccountUpdateInput!, where: AccountWhereInput!): BatchPayload!
  updateManyCategories(data: CategoryUpdateInput!, where: CategoryWhereInput!): BatchPayload!
  updateManyTransactions(data: TransactionUpdateInput!, where: TransactionWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
  deleteManyAccounts(where: AccountWhereInput!): BatchPayload!
  deleteManyCategories(where: CategoryWhereInput!): BatchPayload!
  deleteManyTransactions(where: TransactionWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

enum Operation {
  Plus
  Minus
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  user(where: UserWhereUniqueInput!): User
  account(where: AccountWhereUniqueInput!): Account
  category(where: CategoryWhereUniqueInput!): Category
  transaction(where: TransactionWhereUniqueInput!): Transaction
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  node(id: ID!): Node
}

enum Status {
  None
  Pending
  Paid
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  value: Float!
  operation: Operation
  date: DateTime!
  description: String
  note: String
  status: Status
  delete: Boolean
  deleteDate: DateTime
  category: CategoryCreateOneWithoutTransactionsInput!
  account: AccountCreateOneInput!
  user: UserCreateOneWithoutTransactionsInput!
}

input TransactionCreateManyWithoutCategoryInput {
  create: [TransactionCreateWithoutCategoryInput!]
  connect: [TransactionWhereUniqueInput!]
}

input TransactionCreateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  connect: [TransactionWhereUniqueInput!]
}

input TransactionCreateWithoutCategoryInput {
  value: Float!
  operation: Operation
  date: DateTime!
  description: String
  note: String
  status: Status
  delete: Boolean
  deleteDate: DateTime
  account: AccountCreateOneInput!
  user: UserCreateOneWithoutTransactionsInput!
}

input TransactionCreateWithoutUserInput {
  value: Float!
  operation: Operation
  date: DateTime!
  description: String
  note: String
  status: Status
  delete: Boolean
  deleteDate: DateTime
  category: CategoryCreateOneWithoutTransactionsInput!
  account: AccountCreateOneInput!
}

type TransactionEdge {
  node: Transaction!
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  operation_ASC
  operation_DESC
  date_ASC
  date_DESC
  description_ASC
  description_DESC
  note_ASC
  note_DESC
  status_ASC
  status_DESC
  delete_ASC
  delete_DESC
  deleteDate_ASC
  deleteDate_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TransactionPreviousValues {
  id: ID!
  value: Float!
  operation: Operation!
  date: DateTime!
  description: String
  note: String
  status: Status!
  delete: Boolean
  deleteDate: DateTime
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  AND: [TransactionSubscriptionWhereInput!]
  OR: [TransactionSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
}

input TransactionUpdateInput {
  value: Float
  operation: Operation
  date: DateTime
  description: String
  note: String
  status: Status
  delete: Boolean
  deleteDate: DateTime
  category: CategoryUpdateOneWithoutTransactionsInput
  account: AccountUpdateOneInput
  user: UserUpdateOneWithoutTransactionsInput
}

input TransactionUpdateManyWithoutCategoryInput {
  create: [TransactionCreateWithoutCategoryInput!]
  connect: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  delete: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithoutCategoryInput!]
  upsert: [TransactionUpsertWithoutCategoryInput!]
}

input TransactionUpdateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  connect: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  delete: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithoutUserInput!]
  upsert: [TransactionUpsertWithoutUserInput!]
}

input TransactionUpdateWithoutCategoryDataInput {
  value: Float
  operation: Operation
  date: DateTime
  description: String
  note: String
  status: Status
  delete: Boolean
  deleteDate: DateTime
  account: AccountUpdateOneInput
  user: UserUpdateOneWithoutTransactionsInput
}

input TransactionUpdateWithoutCategoryInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateWithoutCategoryDataInput!
}

input TransactionUpdateWithoutUserDataInput {
  value: Float
  operation: Operation
  date: DateTime
  description: String
  note: String
  status: Status
  delete: Boolean
  deleteDate: DateTime
  category: CategoryUpdateOneWithoutTransactionsInput
  account: AccountUpdateOneInput
}

input TransactionUpdateWithoutUserInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateWithoutUserDataInput!
}

input TransactionUpsertWithoutCategoryInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateWithoutCategoryDataInput!
  create: TransactionCreateWithoutCategoryInput!
}

input TransactionUpsertWithoutUserInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateWithoutUserDataInput!
  create: TransactionCreateWithoutUserInput!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  operation: Operation
  operation_not: Operation
  operation_in: [Operation!]
  operation_not_in: [Operation!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  note: String
  note_not: String
  note_in: [String!]
  note_not_in: [String!]
  note_lt: String
  note_lte: String
  note_gt: String
  note_gte: String
  note_contains: String
  note_not_contains: String
  note_starts_with: String
  note_not_starts_with: String
  note_ends_with: String
  note_not_ends_with: String
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  delete: Boolean
  delete_not: Boolean
  deleteDate: DateTime
  deleteDate_not: DateTime
  deleteDate_in: [DateTime!]
  deleteDate_not_in: [DateTime!]
  deleteDate_lt: DateTime
  deleteDate_lte: DateTime
  deleteDate_gt: DateTime
  deleteDate_gte: DateTime
  category: CategoryWhereInput
  account: AccountWhereInput
  user: UserWhereInput
}

input TransactionWhereUniqueInput {
  id: ID
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  password: String!
  name: String!
  accounts: AccountCreateManyWithoutUserInput
  categories: CategoryCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
}

input UserCreateOneWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCategoriesInput {
  create: UserCreateWithoutCategoriesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAccountsInput {
  email: String!
  password: String!
  name: String!
  categories: CategoryCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
}

input UserCreateWithoutCategoriesInput {
  email: String!
  password: String!
  name: String!
  accounts: AccountCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
}

input UserCreateWithoutTransactionsInput {
  email: String!
  password: String!
  name: String!
  accounts: AccountCreateManyWithoutUserInput
  categories: CategoryCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  accounts: AccountUpdateManyWithoutUserInput
  categories: CategoryUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
}

input UserUpdateOneWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutAccountsInput
  upsert: UserUpsertWithoutAccountsInput
}

input UserUpdateOneWithoutCategoriesInput {
  create: UserCreateWithoutCategoriesInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutCategoriesInput
  upsert: UserUpsertWithoutCategoriesInput
}

input UserUpdateOneWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
  update: UserUpdateWithoutTransactionsInput
  upsert: UserUpsertWithoutTransactionsInput
}

input UserUpdateWithoutAccountsDataInput {
  email: String
  password: String
  name: String
  categories: CategoryUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
}

input UserUpdateWithoutAccountsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutAccountsDataInput!
}

input UserUpdateWithoutCategoriesDataInput {
  email: String
  password: String
  name: String
  accounts: AccountUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
}

input UserUpdateWithoutCategoriesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCategoriesDataInput!
}

input UserUpdateWithoutTransactionsDataInput {
  email: String
  password: String
  name: String
  accounts: AccountUpdateManyWithoutUserInput
  categories: CategoryUpdateManyWithoutUserInput
}

input UserUpdateWithoutTransactionsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutTransactionsDataInput!
}

input UserUpsertWithoutAccountsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutAccountsDataInput!
  create: UserCreateWithoutAccountsInput!
}

input UserUpsertWithoutCategoriesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCategoriesDataInput!
  create: UserCreateWithoutCategoriesInput!
}

input UserUpsertWithoutTransactionsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutTransactionsDataInput!
  create: UserCreateWithoutTransactionsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  accounts_every: AccountWhereInput
  accounts_some: AccountWhereInput
  accounts_none: AccountWhereInput
  categories_every: CategoryWhereInput
  categories_some: CategoryWhereInput
  categories_none: CategoryWhereInput
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
